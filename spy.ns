/** @param {NS} ns **/
export async function main(ns) {

  // setup any flags allowed with the script
  let options = {
    "host": [],
    "hostlist": "",
    "traverse": false,
    "showGrowth": false,
    "sleep": 220,
    "debug": false,
    "verbose": false,
    "rootAcces": true
  };

  // setup any cleanup or exit code
  // ns.atExit();

  // get argument flags through custom function -> i can't get ns.flags to work
  options = await myArgParser(ns, options);

  //// select a function ////
  let myFunctionLoaded = false;

  // getTimings: show host, if it has root access and shows growTime, how much growth it delivers, the current money and max money
  if (!myFunctionLoaded && options.showGrowth) {
    options.debug && ns.tprint("< function loaded >");
    options.debug && options.verbose && ns.tprint("function loaded: showGrowth");

    /** @param {NS} ns **/
    options.myFunction = function (ns, host) {
      let v = [host];
      options.debug && options.verbose && ns.tprint("host:" + host);

      const hasRootAccess = ns.hasRootAccess(host)
      options.debug && options.verbose && ns.tprint("hasRootAccess:" + hasRootAccess);
      v.push(hasRootAccess);

      const getGrowTime = ns.getGrowTime(host)
      options.debug && options.verbose && ns.tprint("getGrowTime:" + getGrowTime);
      v.push(getGrowTime / 1000);

      const getServerGrowth = ns.getServerGrowth(host)
      options.debug && options.verbose && ns.tprint("getServerGrowth:" + getServerGrowth);
      v.push(getServerGrowth);

      const getServerMoneyAvailable = ns.getServerMoneyAvailable(host)
      options.debug && options.verbose && ns.tprint("getServerMoneyAvailable:" + getServerMoneyAvailable);
      v.push(getServerMoneyAvailable / 1000);

      const getServerMaxMoney = ns.getServerMaxMoney(host)
      options.debug && options.verbose && ns.tprint("getServerMaxMoney:" + getServerMaxMoney);
      v.push(getServerMaxMoney / 1000);
      
      if (options.rootAcces == hasRootAccess) {
        ns.tprintf("%s \t [%s] \t --> \t growTime:%.2f \t growth:%d%% \t currentMoney:%.2f k \t maxMoney:%d k", ...v);
      }
    }
    myFunctionLoaded = true;
  }

  if (myFunctionLoaded && options.traverse) {
    options.debug && ns.tprint("< call traverseNetwork >");
    // runs the function that is set in the options
    await traverseNetwork(ns, options);
    ns.exit();
  }

  if (myFunctionLoaded && options.host.length == 1) {
    options.debug && ns.tprint("< run loaded function with given host >");
    // runs the function that is set in the options
    options.myFunction(ns, options.host);
    ns.exit();
  }

  if (myFunctionLoaded) {
    options.debug && ns.tprint("< run loaded function host of where code runs>");
    // runs the function that is set in the options with hostname of where the code runs
    options.myFunction(ns, ns.getHostname());
    ns.exit();
  }

  ns.tprint("pick a function, or check help");
}

/** @param {NS} ns **/
async function myArgParser(ns, options) {
  options.debug && ns.tprint("< argParser running >");
  await ns.sleep(options.sleep);

  let nextArg = false;

  for (let i = 0; i < ns.args.length; i++) {
    const el = ns.args[i];

    if (!nextArg) {
      // check if flags
      const elPrefix = typeof el == "string" ? el.slice(0, 2) : false;
      const option = typeof el == "string" ? el.slice(2) : false;

      if (elPrefix == "--") {
        options.debug && options.verbose && ns.tprint(el + " is a flag");
        // check if in defined options
        options.debug && options.verbose && ns.tprint(option + ":possible option");
        if (option in options) {
          options.debug && options.verbose && ns.tprint(option + ":option identified");
          if (typeof options[option] == 'boolean') {
            options[option] = !options[option];
            options.debug && options.verbose && ns.tprint(option + ":" + options[option] + " -> option switched");
          } else {
            nextArg = option;
          }
        } else {
          ns.tprint(option + " is an unknown flag");
        }
      } else {
        ns.tprint(el + " is unrecognized input");
      }
    } else {
      // check if next arg is input of previous
      if (nextArg) {
        options.debug && options.verbose && ns.tprint(nextArg + " values -> " + el);
        options[nextArg] = el;
        nextArg = false;
      }
    }
  }
  return options;
}

/** @param {NS} ns **/
async function traverseNetwork(ns, options) {
  options.debug && ns.tprint("< traverseNetwork running >");
  await ns.sleep(options.sleep);

  // get server host of options; defaults to current host
  const host = options.host.length == 1 ? options.host : ns.getHostname();

  /** @param {NS} ns **/
  async function traverse(ns, options, host, previous = []) {
    options.debug && ns.tprint("< traverse running >");
    await ns.sleep(options.sleep);
    
    let a = ns.scan(host);
    options.debug && options.verbose && ns.tprint("a: " + a);
    let b = a.filter(value => !previous.includes(value));
    options.debug && options.verbose && ns.tprint("b: " + b);

    while (b.length) {
      let host = b.shift();
      options.debug && options.verbose && ns.tprint("host: " + host);

      previous.push(host);
      options.debug && options.verbose && ns.tprint("previous: " + previous);

      // runs the function that is set in the options
      options.myFunction(ns, host);

      await traverse(ns, options, host, previous);
    }
  }

  await traverse(ns, options, host);
}
